{
  "contractName": "DiamondBase",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "_interfaceID",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "bytecode": "0x608060405234801561001057600080fd5b5060405161234738038061234783398101604081905261002f91610407565b60006100426001600160e01b036103bc16565b80546001600160a01b0319166001600160a01b0384169081178255604051919250906000907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a3600060405161009a906103e0565b604051809103906000f0801580156100b6573d6000803e3d6000fd5b50905060006040516100c7906103ed565b604051809103906000f0801580156100e3573d6000803e3d6000fd5b50905060006040516100f4906103fa565b604051809103906000f080158015610110573d6000803e3d6000fd5b5060408051600480825260a0820190925291925060609190816020015b606081526020019060019003908161012d57505060405190915061015e908590634cfafa9760e11b90602001610435565b6040516020818303038152906040528160008151811061017a57fe5b6020908102919091018101919091526040516101bc9185916356fe50af60e11b91637a0ed62760e01b916366ffd66360e11b916314bbdacb60e21b9101610478565b604051602081830303815290604052816001815181106101d857fe5b60200260200101819052508163f2fde38b60e01b638da5cb5b60e01b604051602001610206939291906104b6565b6040516020818303038152906040528160028151811061022257fe5b6020026020010181905250306301ffc9a760e01b604051602001610247929190610435565b6040516020818303038152906040528160038151811061026357fe5b602002602001018190525060606399f5f52e60e01b8260405160240161028991906104e5565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b03838183161783525050505090506000856001600160a01b0316826040516102d8919061045c565b600060405180830381855af49150503d8060008114610313576040519150601f19603f3d011682016040523d82523d6000602084013e610318565b606091505b50509050806103425760405162461bcd60e51b81526004016103399061055d565b60405180910390fd5b50506301ffc9a760e01b6000908152600490950160205250506040808420805460ff199081166001908117909255634cfafa9760e11b865282862080548216831790556348e2b09360e01b865282862080548216831790556307f5828d60e41b8652919094208054909116909317909255506105c4915050565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90565b61096a8061082283390190565b610f728061118c83390190565b610249806120fe83390190565b600060208284031215610418578081fd5b81516001600160a01b038116811461042e578182fd5b9392505050565b60609290921b6001600160601b03191682526001600160e01b031916601482015260180190565b6000825161046e818460208701610594565b9190910192915050565b60609590951b6001600160601b03191685526001600160e01b0319938416601486015291831660188501528216601c84015216602082015260240190565b60609390931b6001600160601b03191683526001600160e01b03199182166014840152166018820152601c0190565b6000602080830181845280855180835260408601915060408482028701019250838701855b8281101561055057878503603f1901845281518051808752610531818989018a8501610594565b601f01601f19169590950186019450928501929085019060010161050a565b5092979650505050505050565b60208082526018908201527f416464696e672066756e6374696f6e73206661696c65642e0000000000000000604082015260600190565b60005b838110156105af578181015183820152602001610597565b838111156105be576000848401525b50505050565b61024f806105d36000396000f3fe6080604052600436106100225760003560e01c806301ffc9a71461010457610029565b3661002957005b600080357fffffffff000000000000000000000000000000000000000000000000000000001681527fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131d60205260409020547fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c9060601c806100df576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016100d6906101e2565b60405180910390fd5b60405136600082376000803683855af43d806000843e818015610100578184f35b8184fd5b34801561011057600080fd5b5061012461011f366004610190565b61013a565b60405161013191906101d7565b60405180910390f35b7fffffffff000000000000000000000000000000000000000000000000000000001660009081527fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c1320602052604090205460ff1690565b6000602082840312156101a1578081fd5b81357fffffffff00000000000000000000000000000000000000000000000000000000811681146101d0578182fd5b9392505050565b901515815260200190565b60208082526018908201527f46756e6374696f6e20646f6573206e6f742065786973742e000000000000000060408201526060019056fea2646970667358221220b4f701ffba77c145c1ab2815f67fa4d820d0639e28f1513e0481c94bab58fd8b64736f6c63430006050033608060405234801561001057600080fd5b5061094a806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c806399f5f52e14610030575b600080fd5b61004361003e36600461069b565b610045565b005b600061004f6105d9565b805490915073ffffffffffffffffffffffffffffffffffffffff1633146100915760405162461bcd60e51b8152600401610088906107eb565b60405180910390fd5b6100996105fd565b60038201548082526fffffffffffffffffffffffffffffffff81169060801c80156100d7576000828152600285016020908152604090912054908401525b60005b85518110156105525760608682815181106100f157fe5b60200260200101519050601481511161011c5760405162461bcd60e51b81526004016100889061087f565b602081015181516bffffffffffffffffffffffff1982169060047fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec90910104603482156103185760005b8281101561031257858201516001600160e01b03198116600090815260018d016020526040902054600490930192806102a75760018c60a00190151590811515815250508a60001b60408b60001b901b8717178d6001016000847bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681526020019081526020016000208190555089602002827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916901c8a6020026001600160e01b031960001b901c198d6020015116178c602001818152505089806001019a505089600814156102a2578b602001518d60020160008d8152602001908152602001600020819055506000801b8c6020018181525050600099508a806001019b50505b610308565b6bffffffffffffffffffffffff1981811690871614156102d95760405162461bcd60e51b8152600401610088906108b6565b6001600160e01b03198216600090815260018e01602052604090206bffffffffffffffffffffffff8216871790555b5050600101610166565b50610541565b600160a08a015260005b8281101561053f57858201516001600160e01b03198116600090815260018d0160205260409020546004909301928061036d5760405162461bcd60e51b815260040161008890610822565b60208c015161039a57600019909a01600081815260028e016020908152604090912054908d015299600899505b67ffffffffffffffff811660408d810182905282901c63ffffffff1660608e01526020808e01516000198d019091021b908c14610475578d60020160008e604001518152602001908152602001600020548d60800181815250508c60600151602002817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916901c8d606001516020026001600160e01b031960001b901c198e6080015116178d60800181815250508c608001518e60020160008f604001518152602001908152602001600020819055508a80600190039b50506104a7565b60608d01516020808f0180516001600160e01b03199290930282811c199390931691841690921c179052600019909a01995b8a6104c55760008c815260028f016020908152604082208290558e01525b6001600160e01b031981811690841614610518576001600160e01b03198116600090815260018f016020526040902080546bffffffffffffffffffffffff19166bffffffffffffffffffffffff84161790555b50506001600160e01b03191660009081526001808d01602052604082209190915501610322565b505b5050600190930192506100da915050565b508251608082901b831790811461056b57600385018190555b8360a00151801561057c5750600082115b1561059a576020808501516000858152600288019092526040909120555b7f6ace155508eb66f4d8afce32f392ee3b0a8ab3c0133964f1f3c613e497da45fe866040516105c99190610736565b60405180910390a1505050505050565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90565b6040805160c081018252600080825260208201819052918101829052606081018290526080810182905260a081019190915290565b600082601f830112610642578081fd5b813567ffffffffffffffff811115610658578182fd5b61066b6020601f19601f840116016108ed565b915080825283602082850101111561068257600080fd5b8060208401602084013760009082016020015292915050565b600060208083850312156106ad578182fd5b823567ffffffffffffffff808211156106c4578384fd5b81850186601f8201126106d5578485fd5b80359250818311156106e5578485fd5b6106f284858502016108ed565b8381528481019250818501865b85811015610728576107168a888435870101610632565b855293860193908601906001016106ff565b509098975050505050505050565b6000602080830181845280855180835260408601915060408482028701019250838701855b828110156107de577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc088860301845281518051808752885b818110156107ae578281018901518882018a01528801610793565b818111156107be578989838a0101525b50601f01601f19169590950186019450928501929085019060010161075b565b5092979650505050505050565b60208082526016908201527f4d757374206f776e2074686520636f6e74726163742e00000000000000000000604082015260600190565b60208082526025908201527f46756e6374696f6e20646f65736e27742065786973742e2043616e277420726560408201527f6d6f76652e000000000000000000000000000000000000000000000000000000606082015260800190565b6020808252601f908201527f4d697373696e67206661636574206f722073656c6563746f7220696e666f2e00604082015260600190565b6020808252601b908201527f46756e6374696f6e2063757420746f2073616d652066616365742e0000000000604082015260600190565b60405181810167ffffffffffffffff8111828210171561090c57600080fd5b60405291905056fea264697066735822122034c2755f229335f7660a3ce1dbed58d9481f76e5ea33830cb732ee6a5eb62e7764736f6c63430006050033608060405234801561001057600080fd5b50610f52806100206000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c806352ef6b2c146100515780637a0ed6271461006f578063adfca15e14610084578063cdffacc614610097575b600080fd5b6100596100b7565b6040516100669190610ed9565b60405180910390f35b610077610340565b6040516100669190610e5b565b610059610092366004610d42565b610ab3565b6100aa6100a5366004610d7d565b610cd3565b6040516100669190610e3a565b606060006100c3610d06565b60038101549091506fffffffffffffffffffffffffffffffff60088202608083901c011660608167ffffffffffffffff8111801561010057600080fd5b5060405190808252806020026020018201604052801561012a578160200160208202803683370190505b50905060008060005b84821015610253576000818152600288016020526040812054905b6008811015610249576001909301928684111561016a57610249565b6001600160e01b0319602080830284901b918216600090815260018c01909152604081205460601c90805b888110156101f5578981815181106101a957fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614156101ed57600191506101f5565b600101610195565b5080156102055750610241915050565b8189898151811061021257fe5b73ffffffffffffffffffffffffffffffffffffffff909216602092830291909101909101525050600190950194505b60010161014e565b5050600101610133565b5060608260140267ffffffffffffffff8111801561027057600080fd5b506040519080825280601f01601f19166020018201604052801561029b576020820181803683370190505b5090506000805b848110156103325760005b601481101561032957806008028783815181106102c657fe5b602002602001015160601b6bffffffffffffffffffffffff1916901b8484815181106102ee57fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600192830192016102ad565b506001016102a2565b509097505050505050505090565b6060600061034c610d06565b60038101549091506fffffffffffffffffffffffffffffffff60088202608083901c011680601481111561037e575060145b60608167ffffffffffffffff8111801561039757600080fd5b506040519080825280602002602001820160405280156103d157816020015b6103be610d2a565b8152602001906001900390816103b65790505b50905060608267ffffffffffffffff811180156103ed57600080fd5b50604051908082528060200260200182016040528015610417578160200160208202803683370190505b50905060008060005b868210156108da57600081815260028a016020526040812054905b60088110156108d05760019093019288841115610457576108d0565b6001600160e01b0319602080830284901b918216600090815260018e01909152604081205460601c90805b88811015610693578273ffffffffffffffffffffffffffffffffffffffff168b82815181106104ad57fe5b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff16141561068b5760008b82815181106104e357fe5b602002602001015160200151519050808b83815181106104ff57fe5b602002602001015160010160ff1611156105dd5760608d820167ffffffffffffffff8111801561052e57600080fd5b50604051908082528060200260200182016040528015610558578160200160208202803683370190505b50905060005b828110156105be578d848151811061057257fe5b602002602001015160200151818151811061058957fe5b602002602001015182828151811061059d57fe5b6001600160e01b03199092166020928302919091019091015260010161055e565b50808d84815181106105cc57fe5b602002602001015160200181905250505b848c83815181106105ea57fe5b6020026020010151602001518c848151811061060257fe5b602002602001015160ff168151811061061757fe5b60200260200101906001600160e01b03191690816001600160e01b0319168152505060ff8b838151811061064757fe5b602002602001015160ff161061065c57600080fd5b8a828151811061066857fe5b60200260200101805180919060010160ff1660ff16815250506001925050610693565b600101610482565b5080156106a357506108c8915050565b8951600189018110156107c75760608c820167ffffffffffffffff811180156106cb57600080fd5b5060405190808252806020026020018201604052801561070557816020015b6106f2610d2a565b8152602001906001900390816106ea5790505b50905060608d830167ffffffffffffffff8111801561072357600080fd5b5060405190808252806020026020018201604052801561074d578160200160208202803683370190505b50905060005b838110156107c0578d818151811061076757fe5b602002602001015183828151811061077b57fe5b60200260200101819052508c818151811061079257fe5b60200260200101518282815181106107a657fe5b60ff90921660209283029190910190910152600101610753565b50909b5099505b828b8a815181106107d457fe5b602090810291909101015173ffffffffffffffffffffffffffffffffffffffff90911690528b67ffffffffffffffff8111801561081057600080fd5b5060405190808252806020026020018201604052801561083a578160200160208202803683370190505b508b8a8151811061084757fe5b602002602001015160200181905250838b8a8151811061086357fe5b60200260200101516020015160008151811061087b57fe5b60200260200101906001600160e01b03191690816001600160e01b0319168152505060018a8a815181106108ab57fe5b60ff90921660209283029190910190910152505060019096019550505b60010161043b565b5050600101610420565b5060608267ffffffffffffffff811180156108f457600080fd5b5060405190808252806020026020018201604052801561092857816020015b60608152602001906001900390816109135790505b50905060005b83811015610aa557600085828151811061094457fe5b602002602001015160ff16905060608160040267ffffffffffffffff8111801561096d57600080fd5b506040519080825280601f01601f191660200182016040528015610998576020820181803683370190505b50905060608884815181106109a957fe5b60200260200101516020015190506000805b84811015610a435760005b6004811015610a3a57806008028483815181106109df57fe5b60200260200101516001600160e01b031916901b8584815181106109ff57fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600192830192016109c6565b506001016109bb565b50898581518110610a5057fe5b60200260200101516000015183604051602001610a6e929190610def565b604051602081830303815290604052868681518110610a8957fe5b602002602001018190525050505050808060010191505061092e565b509850505050505050505090565b60606000610abf610d06565b60038101549091506fffffffffffffffffffffffffffffffff60088202608083901c0116600060608267ffffffffffffffff81118015610afe57600080fd5b50604051908082528060200260200182016040528015610b28578160200160208202803683370190505b5090506000805b84821015610bed576000818152600288016020526040812054905b6008811015610be35760019093019286841115610b6657610be3565b6001600160e01b0319602080830284901b918216600090815260018c01909152604090205460601c73ffffffffffffffffffffffffffffffffffffffff8d16811415610bd95781878981518110610bb957fe5b6001600160e01b0319909216602092830291909101909101526001909701965b5050600101610b4a565b5050600101610b2f565b5060608360040267ffffffffffffffff81118015610c0a57600080fd5b506040519080825280601f01601f191660200182016040528015610c35576020820181803683370190505b5090506000805b85811015610cc45760005b6004811015610cbb5780600802868381518110610c6057fe5b60200260200101516001600160e01b031916901b848481518110610c8057fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535060019283019201610c47565b50600101610c3c565b50909998505050505050505050565b600080610cde610d06565b6001600160e01b0319841660009081526001909101602052604090205460601c915050919050565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90565b60408051808201909152600081526060602082015290565b600060208284031215610d53578081fd5b813573ffffffffffffffffffffffffffffffffffffffff81168114610d76578182fd5b9392505050565b600060208284031215610d8e578081fd5b81356001600160e01b031981168114610d76578182fd5b60008151808452610dbd816020860160208601610eec565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b60007fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008460601b1682528251610e2c816014850160208701610eec565b919091016014019392505050565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b6000602080830181845280855180835260408601915060408482028701019250838701855b82811015610ecc577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0888603018452610eba858351610da5565b94509285019290850190600101610e80565b5092979650505050505050565b600060208252610d766020830184610da5565b60005b83811015610f07578181015183820152602001610eef565b83811115610f16576000848401525b5050505056fea2646970667358221220a85d71db8d9b8993896da6abf84589c2a75f5e16215c97eb0aa4f70cf31b647764736f6c63430006050033608060405234801561001057600080fd5b50610229806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80638da5cb5b1461003b578063f2fde38b1461006c575b600080fd5b6100436100a1565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b61009f6004803603602081101561008257600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166100c9565b005b6000806100ac6101cf565b5473ffffffffffffffffffffffffffffffffffffffff1691505090565b60006100d36101cf565b805490915073ffffffffffffffffffffffffffffffffffffffff1633811461015c57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4d757374206f776e2074686520636f6e74726163742e00000000000000000000604482015290519081900360640190fd5b81547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff8481169182178455604051908316907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a3505050565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c9056fea264697066735822122006380dfbb347f0122bebd89924212f5c42f5746cfe504236d4e743bffbc45d3f64736f6c63430006050033",
  "deployedBytecode": "0x6080604052600436106100225760003560e01c806301ffc9a71461010457610029565b3661002957005b600080357fffffffff000000000000000000000000000000000000000000000000000000001681527fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131d60205260409020547fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c9060601c806100df576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016100d6906101e2565b60405180910390fd5b60405136600082376000803683855af43d806000843e818015610100578184f35b8184fd5b34801561011057600080fd5b5061012461011f366004610190565b61013a565b60405161013191906101d7565b60405180910390f35b7fffffffff000000000000000000000000000000000000000000000000000000001660009081527fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c1320602052604090205460ff1690565b6000602082840312156101a1578081fd5b81357fffffffff00000000000000000000000000000000000000000000000000000000811681146101d0578182fd5b9392505050565b901515815260200190565b60208082526018908201527f46756e6374696f6e20646f6573206e6f742065786973742e000000000000000060408201526060019056fea2646970667358221220b4f701ffba77c145c1ab2815f67fa4d820d0639e28f1513e0481c94bab58fd8b64736f6c63430006050033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "metadata": "{\"compiler\":{\"version\":\"0.6.5+commit.f956cc89\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"solc_0.6/proxy/diamond/DiamondBase.sol\":\"DiamondBase\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"solc_0.6/proxy/diamond/DiamondBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.4;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge\\n* from https://github.com/mudgen/Diamond/blob/ca15562a2858a4a4696526b1f6b18a4adef10617/contracts/\\n*\\n* slightly modified by Ronan Sandford\\n* modifications includes\\n* - formatting\\n* - rename to DiamondBase\\n* - allow to pass owner in constructor\\n* - reject on receive()\\n* - use ERC173Events for Ownership event\\n* - use OwnershipFacet for allowing owner to change owner\\n*\\n* Implementation of an example of a diamond.\\n/******************************************************************************/\\n\\nimport \\\"./ERC173.sol\\\";\\nimport \\\"./OwnershipFacet.sol\\\";\\nimport \\\"./DiamondStorageContract.sol\\\";\\nimport \\\"./DiamondHeaders.sol\\\";\\nimport \\\"./DiamondFacet.sol\\\";\\nimport \\\"./DiamondLoupeFacet.sol\\\";\\n\\ncontract DiamondBase is ERC173Events, DiamondStorageContract {\\n    constructor(address owner) public {\\n        DiamondStorage storage ds = diamondStorage();\\n        ds.contractOwner = owner;\\n        emit OwnershipTransferred(address(0), owner);\\n\\n        // Create a DiamondFacet contract which implements the Diamond interface\\n        DiamondFacet diamondFacet = new DiamondFacet();\\n\\n        // Create a DiamondLoupeFacet contract which implements the Diamond Loupe interface\\n        DiamondLoupeFacet diamondLoupeFacet = new DiamondLoupeFacet();\\n\\n        // Create a OwnershipFacet contract which implements the ERC-173 Ownership interface\\n        OwnershipFacet ownershipFacet = new OwnershipFacet();\\n\\n        bytes[] memory diamondCut = new bytes[](4);\\n\\n        // Adding cut function\\n        diamondCut[0] = abi.encodePacked(\\n            diamondFacet,\\n            Diamond.diamondCut.selector\\n        );\\n\\n        // Adding diamond loupe functions\\n        diamondCut[1] = abi.encodePacked(\\n            diamondLoupeFacet,\\n            DiamondLoupe.facetFunctionSelectors.selector,\\n            DiamondLoupe.facets.selector,\\n            DiamondLoupe.facetAddress.selector,\\n            DiamondLoupe.facetAddresses.selector\\n        );\\n\\n        // Adding diamond ERC173 functions\\n        diamondCut[2] = abi.encodePacked(\\n            ownershipFacet,\\n            ERC173.transferOwnership.selector,\\n            ERC173.owner.selector\\n        );\\n\\n        // Adding supportsInterface function\\n        diamondCut[3] = abi.encodePacked(\\n            address(this),\\n            ERC165.supportsInterface.selector\\n        );\\n\\n        // execute cut function\\n        bytes memory cutFunction = abi.encodeWithSelector(\\n            Diamond.diamondCut.selector,\\n            diamondCut\\n        );\\n        (bool success, ) = address(diamondFacet).delegatecall(cutFunction);\\n        require(success, \\\"Adding functions failed.\\\");\\n\\n        // adding ERC165 data\\n        // ERC165\\n        ds.supportedInterfaces[ERC165.supportsInterface.selector] = true;\\n\\n        // DiamondCut\\n        ds.supportedInterfaces[Diamond.diamondCut.selector] = true;\\n\\n        // DiamondLoupe\\n        bytes4 interfaceID = DiamondLoupe.facets.selector ^\\n            DiamondLoupe.facetFunctionSelectors.selector ^\\n            DiamondLoupe.facetAddresses.selector ^\\n            DiamondLoupe.facetAddress.selector;\\n        ds.supportedInterfaces[interfaceID] = true;\\n\\n        // ERC173\\n        ds.supportedInterfaces[ERC173.transferOwnership.selector ^\\n            ERC173.owner.selector] = true;\\n    }\\n\\n    // This is an immutable functions because it is defined directly in the diamond.\\n    // This implements ERC-165.\\n    function supportsInterface(bytes4 _interfaceID)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        DiamondStorage storage ds;\\n        assembly {\\n            ds_slot := 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c\\n        }\\n        return ds.supportedInterfaces[_interfaceID];\\n    }\\n\\n    // Finds facet for function that is called and executes the\\n    // function if it is found and returns any value.\\n    fallback() external payable {\\n        DiamondStorage storage ds;\\n        assembly {\\n            ds_slot := 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c\\n        }\\n        address facet = address(bytes20(ds.facets[msg.sig]));\\n        require(facet != address(0), \\\"Function does not exist.\\\");\\n        assembly {\\n            let ptr := mload(0x40)\\n            calldatacopy(ptr, 0, calldatasize())\\n            let result := delegatecall(gas(), facet, ptr, calldatasize(), 0, 0)\\n            let size := returndatasize()\\n            returndatacopy(ptr, 0, size)\\n            switch result\\n                case 0 {\\n                    revert(ptr, size)\\n                }\\n                default {\\n                    return(ptr, size)\\n                }\\n        }\\n    }\\n\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0xd713db90264cd9ed4e18f4557d42511e51009bf211e7d64f526f81ba90f61a37\"},\"solc_0.6/proxy/diamond/DiamondFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.4;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge\\n* from https://github.com/mudgen/Diamond/blob/ca15562a2858a4a4696526b1f6b18a4adef10617/contracts/\\n*\\n* Implementation of Diamond facet.\\n* This is gas optimized by reducing storage reads and storage writes.\\n* This code is as complex as it is to reduce gas costs.\\n/******************************************************************************/\\n\\nimport \\\"./DiamondStorageContract.sol\\\";\\nimport \\\"./DiamondHeaders.sol\\\";\\n\\ncontract DiamondFacet is Diamond, DiamondStorageContract {\\n    bytes32 constant CLEAR_ADDRESS_MASK = 0x0000000000000000000000000000000000000000ffffffffffffffffffffffff;\\n    bytes32 constant CLEAR_SELECTOR_MASK = 0xffffffff00000000000000000000000000000000000000000000000000000000;\\n\\n    // This struct is used to prevent getting the error \\\"CompilerError: Stack too deep, try removing local variables.\\\"\\n    // See this article: https://medium.com/1milliondevs/compilererror-stack-too-deep-try-removing-local-variables-solved-a6bcecc16231\\n    struct SlotInfo {\\n        uint originalSelectorSlotsLength;\\n        bytes32 selectorSlot;\\n        uint oldSelectorSlotsIndex;\\n        uint oldSelectorSlotIndex;\\n        bytes32 oldSelectorSlot;\\n        bool updateLastSlot;\\n    }\\n\\n    function diamondCut(bytes[] memory _diamondCut) public override {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(msg.sender == ds.contractOwner, \\\"Must own the contract.\\\");\\n        SlotInfo memory slot;\\n        slot.originalSelectorSlotsLength = ds.selectorSlotsLength;\\n        uint selectorSlotsLength = uint128(slot.originalSelectorSlotsLength);\\n        uint selectorSlotLength = uint128(slot.originalSelectorSlotsLength >> 128);\\n        if(selectorSlotLength > 0) {\\n            slot.selectorSlot = ds.selectorSlots[selectorSlotsLength];\\n        }\\n        // loop through diamond cut\\n        for(uint diamondCutIndex; diamondCutIndex < _diamondCut.length; diamondCutIndex++) {\\n            bytes memory facetCut = _diamondCut[diamondCutIndex];\\n            require(facetCut.length > 20, \\\"Missing facet or selector info.\\\");\\n            bytes32 currentSlot;\\n            assembly {\\n                currentSlot := mload(add(facetCut,32))\\n            }\\n            bytes32 newFacet = bytes20(currentSlot);\\n            uint numSelectors = (facetCut.length - 20) / 4;\\n            uint position = 52;\\n\\n            // adding or replacing functions\\n            if(newFacet != 0) {                \\n                // add and replace selectors\\n                for(uint selectorIndex; selectorIndex < numSelectors; selectorIndex++) {\\n                    bytes4 selector;\\n                    assembly {\\n                        selector := mload(add(facetCut,position))\\n                    }\\n                    position += 4;\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    // add\\n                    if(oldFacet == 0) {\\n                        // update the last slot at then end of the function\\n                        slot.updateLastSlot = true;\\n                        ds.facets[selector] = newFacet | bytes32(selectorSlotLength) << 64 | bytes32(selectorSlotsLength);\\n                        // clear selector position in slot and add selector\\n                        slot.selectorSlot = slot.selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorSlotLength * 32) | bytes32(selector) >> selectorSlotLength * 32;\\n                        selectorSlotLength++;\\n                        // if slot is full then write it to storage\\n                        if(selectorSlotLength == 8) {\\n                            ds.selectorSlots[selectorSlotsLength] = slot.selectorSlot;\\n                            slot.selectorSlot = 0;\\n                            selectorSlotLength = 0;\\n                            selectorSlotsLength++;\\n                        }\\n                    }\\n                    // replace\\n                    else {\\n                        require(bytes20(oldFacet) != bytes20(newFacet), \\\"Function cut to same facet.\\\");\\n                        // replace old facet address\\n                        ds.facets[selector] = oldFacet & CLEAR_ADDRESS_MASK | newFacet;\\n                    }\\n                }\\n            }\\n            // remove functions\\n            else {\\n                slot.updateLastSlot = true;\\n                for(uint selectorIndex; selectorIndex < numSelectors; selectorIndex++) {\\n                    bytes4 selector;\\n                    assembly {\\n                        selector := mload(add(facetCut,position))\\n                    }\\n                    position += 4;\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    require(oldFacet != 0, \\\"Function doesn't exist. Can't remove.\\\");\\n                    // Current slot is empty so get the slot before it\\n                    if(slot.selectorSlot == 0) {\\n                        selectorSlotsLength--;\\n                        slot.selectorSlot = ds.selectorSlots[selectorSlotsLength];\\n                        selectorSlotLength = 8;\\n                    }\\n                    slot.oldSelectorSlotsIndex = uint64(uint(oldFacet));\\n                    slot.oldSelectorSlotIndex = uint32(uint(oldFacet >> 64));\\n                    // gets the last selector in the slot\\n                    bytes4 lastSelector = bytes4(slot.selectorSlot << (selectorSlotLength-1) * 32);\\n                    if(slot.oldSelectorSlotsIndex != selectorSlotsLength) {\\n                        slot.oldSelectorSlot = ds.selectorSlots[slot.oldSelectorSlotsIndex];\\n                        // clears the selector we are deleting and puts the last selector in its place.\\n                        slot.oldSelectorSlot = slot.oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> slot.oldSelectorSlotIndex * 32) | bytes32(lastSelector) >> slot.oldSelectorSlotIndex * 32;\\n                        // update storage with the modified slot\\n                        ds.selectorSlots[slot.oldSelectorSlotsIndex] = slot.oldSelectorSlot;\\n                        selectorSlotLength--;\\n                    }\\n                    else {\\n                        // clears the selector we are deleting and puts the last selector in its place.\\n                        slot.selectorSlot = slot.selectorSlot & ~(CLEAR_SELECTOR_MASK >> slot.oldSelectorSlotIndex * 32) | bytes32(lastSelector) >> slot.oldSelectorSlotIndex * 32;\\n                        selectorSlotLength--;                        \\n                    }\\n                    if(selectorSlotLength == 0) {\\n                        delete ds.selectorSlots[selectorSlotsLength];\\n                        slot.selectorSlot = 0;                        \\n                    }\\n                    if(lastSelector != selector) {\\n                        // update last selector slot position info\\n                        ds.facets[lastSelector] = oldFacet & CLEAR_ADDRESS_MASK | bytes20(ds.facets[lastSelector]);\\n                    }\\n                    delete ds.facets[selector];\\n                }\\n            }\\n        }\\n        uint newSelectorSlotsLength = selectorSlotLength << 128 | selectorSlotsLength;\\n        if(newSelectorSlotsLength != slot.originalSelectorSlotsLength) {\\n            ds.selectorSlotsLength = newSelectorSlotsLength;\\n        }\\n        if(slot.updateLastSlot && selectorSlotLength > 0) {\\n            ds.selectorSlots[selectorSlotsLength] = slot.selectorSlot;\\n        }\\n        emit DiamondCut(_diamondCut);\\n    }\\n}\\n\",\"keccak256\":\"0x867d27a7d3f2720f8287c7378ee620f92708af6f14e4d65b457d7d80a28d7505\"},\"solc_0.6/proxy/diamond/DiamondHeaders.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.4;\\npragma experimental ABIEncoderV2;\\n\\n// * from https://github.com/mudgen/Diamond/blob/ca15562a2858a4a4696526b1f6b18a4adef10617/contracts/\\n\\ninterface Diamond {\\n    /// @notice _diamondCut is an array of bytes arrays.\\n    /// This argument is tightly packed for gas efficiency.\\n    /// That means no padding with zeros.\\n    /// Here is the structure of _diamondCut:\\n    /// _diamondCut = [\\n    ///     abi.encodePacked(facet, sel1, sel2, sel3, ...),\\n    ///     abi.encodePacked(facet, sel1, sel2, sel4, ...),\\n    ///     ...\\n    /// ]\\n    /// facet is the address of a facet\\n    /// sel1, sel2, sel3 etc. are four-byte function selectors.\\n    function diamondCut(bytes[] calldata _diamondCut) external;\\n\\n    event DiamondCut(bytes[] _diamondCut);\\n}\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface DiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools. Therefore the return values are tightly\\n    /// packed for efficiency. That means no padding with zeros.\\n\\n    /// @notice Gets all facets and their selectors.\\n    /// @return An array of bytes arrays containing each facet\\n    ///         and each facet's selectors.\\n    /// The return value is tightly packed.\\n    /// Here is the structure of the return value:\\n    /// returnValue = [\\n    ///     abi.encodePacked(facet, sel1, sel2, sel3, ...),\\n    ///     abi.encodePacked(facet, sel1, sel2, sel3, ...),\\n    ///     ...\\n    /// ]\\n    /// facet is the address of a facet.\\n    /// sel1, sel2, sel3 etc. are four-byte function selectors.\\n    function facets() external view returns (bytes[] memory);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return A byte array of function selectors.\\n    /// The return value is tightly packed. Here is an example:\\n    /// return abi.encodePacked(selector1, selector2, selector3, ...)\\n    function facetFunctionSelectors(address _facet)\\n        external\\n        view\\n        returns (bytes memory);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return A byte array of tightly packed facet addresses.\\n    /// Example return value:\\n    /// return abi.encodePacked(facet1, facet2, facet3, ...)\\n    function facetAddresses() external view returns (bytes memory);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return The facet address.\\n    function facetAddress(bytes4 _functionSelector)\\n        external\\n        view\\n        returns (address);\\n}\\n\\ninterface ERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x43c64e4e226daebea90ba476426d59e768acc70dcd4f85f08efbcdde368998c9\"},\"solc_0.6/proxy/diamond/DiamondLoupeFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.4;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge\\n* from https://github.com/mudgen/Diamond/blob/ca15562a2858a4a4696526b1f6b18a4adef10617/contracts/\\n*\\n* Implementation of DiamondLoupe interface.\\n/******************************************************************************/\\n\\nimport \\\"./DiamondStorageContract.sol\\\";\\nimport \\\"./DiamondHeaders.sol\\\";\\n\\ncontract DiamondLoupeFacet is DiamondLoupe, DiamondStorageContract {\\n    /// These functions are expected to be called frequently\\n    /// by tools. Therefore the return values are tightly\\n    /// packed for efficiency. That means no padding with zeros.\\n\\n    struct Facet {\\n        address facet;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facets and their selectors.\\n    /// @return An array of bytes arrays containing each facet\\n    ///         and each facet's selectors.\\n    /// The return value is tightly packed.\\n    /// That means no padding with zeros.\\n    /// Here is the structure of the return value:\\n    /// returnValue = [\\n    ///     abi.encodePacked(facet, sel1, sel2, sel3, ...),\\n    ///     abi.encodePacked(facet, sel1, sel2, sel3, ...),\\n    ///     ...\\n    /// ]\\n    /// facet is the address of a facet.\\n    /// sel1, sel2, sel3 etc. are four-byte function selectors.\\n    function facets() external override view returns (bytes[] memory) {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 totalSelectorSlots = ds.selectorSlotsLength;\\n        uint256 totalSelectors = uint128(totalSelectorSlots) *\\n            8 +\\n            uint128(totalSelectorSlots >> 128);\\n\\n        // get default size of arrays\\n        uint256 defaultSize = totalSelectors;\\n        if (defaultSize > 20) {\\n            defaultSize = 20;\\n        }\\n        Facet[] memory facets_ = new Facet[](defaultSize);\\n        uint8[] memory numFacetSelectors = new uint8[](defaultSize);\\n        uint256 numFacets;\\n        uint256 selectorCount;\\n        // loop through function selectors\\n        for (uint256 slotIndex; selectorCount < totalSelectors; slotIndex++) {\\n            bytes32 slot = ds.selectorSlots[slotIndex];\\n            for (uint256 selectorIndex; selectorIndex < 8; selectorIndex++) {\\n                selectorCount++;\\n                if (selectorCount > totalSelectors) {\\n                    break;\\n                }\\n                bytes4 selector = bytes4(slot << (selectorIndex * 32));\\n                address facet = address(bytes20(ds.facets[selector]));\\n                bool continueLoop = false;\\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n                    if (facets_[facetIndex].facet == facet) {\\n                        uint256 arrayLength = facets_[facetIndex]\\n                            .functionSelectors\\n                            .length;\\n                        // if array is too small then enlarge it\\n                        if (numFacetSelectors[facetIndex] + 1 > arrayLength) {\\n                            bytes4[] memory biggerArray = new bytes4[](\\n                                arrayLength + defaultSize\\n                            );\\n                            // copy contents of old array\\n                            for (uint256 i; i < arrayLength; i++) {\\n                                biggerArray[i] = facets_[facetIndex]\\n                                    .functionSelectors[i];\\n                            }\\n                            facets_[facetIndex].functionSelectors = biggerArray;\\n                        }\\n                        facets_[facetIndex]\\n                            .functionSelectors[numFacetSelectors[facetIndex]] = selector;\\n                        // probably will never have more than 255 functions from one facet contract\\n                        require(numFacetSelectors[facetIndex] < 255);\\n                        numFacetSelectors[facetIndex]++;\\n                        continueLoop = true;\\n                        break;\\n                    }\\n                }\\n                if (continueLoop) {\\n                    continueLoop = false;\\n                    continue;\\n                }\\n                uint256 arrayLength = facets_.length;\\n                // if array is too small then enlarge it\\n                if (numFacets + 1 > arrayLength) {\\n                    Facet[] memory biggerArray = new Facet[](\\n                        arrayLength + defaultSize\\n                    );\\n                    uint8[] memory biggerArray2 = new uint8[](\\n                        arrayLength + defaultSize\\n                    );\\n                    for (uint256 i; i < arrayLength; i++) {\\n                        biggerArray[i] = facets_[i];\\n                        biggerArray2[i] = numFacetSelectors[i];\\n                    }\\n                    facets_ = biggerArray;\\n                    numFacetSelectors = biggerArray2;\\n                }\\n                facets_[numFacets].facet = facet;\\n                facets_[numFacets].functionSelectors = new bytes4[](\\n                    defaultSize\\n                );\\n                facets_[numFacets].functionSelectors[0] = selector;\\n                numFacetSelectors[numFacets] = 1;\\n                numFacets++;\\n            }\\n        }\\n        bytes[] memory returnFacets = new bytes[](numFacets);\\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n            uint256 numSelectors = numFacetSelectors[facetIndex];\\n            bytes memory selectorsBytes = new bytes(4 * numSelectors);\\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\\n            uint256 bytePosition;\\n            for (uint256 i; i < numSelectors; i++) {\\n                for (uint256 j; j < 4; j++) {\\n                    selectorsBytes[bytePosition] = bytes1(\\n                        selectors[i] << (j * 8)\\n                    );\\n                    bytePosition++;\\n                }\\n            }\\n            returnFacets[facetIndex] = abi.encodePacked(\\n                facets_[facetIndex].facet,\\n                selectorsBytes\\n            );\\n        }\\n        return returnFacets;\\n    }\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return A bytes array of function selectors.\\n    /// The return value is tightly packed. Here is an example:\\n    /// return abi.encodePacked(selector1, selector2, selector3, ...)\\n    function facetFunctionSelectors(address _facet)\\n        external\\n        override\\n        view\\n        returns (bytes memory)\\n    {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 totalSelectorSlots = ds.selectorSlotsLength;\\n        uint256 totalSelectors = uint128(totalSelectorSlots) *\\n            8 +\\n            uint128(totalSelectorSlots >> 128);\\n\\n        uint256 numFacetSelectors;\\n        bytes4[] memory facetSelectors = new bytes4[](totalSelectors);\\n        uint256 selectorCount;\\n        // loop through function selectors\\n        for (uint256 slotIndex; selectorCount < totalSelectors; slotIndex++) {\\n            bytes32 slot = ds.selectorSlots[slotIndex];\\n            for (uint256 selectorIndex; selectorIndex < 8; selectorIndex++) {\\n                selectorCount++;\\n                if (selectorCount > totalSelectors) {\\n                    break;\\n                }\\n                bytes4 selector = bytes4(slot << (selectorIndex * 32));\\n                address facet = address(bytes20(ds.facets[selector]));\\n                if (_facet == facet) {\\n                    facetSelectors[numFacetSelectors] = selector;\\n                    numFacetSelectors++;\\n                }\\n            }\\n        }\\n        bytes memory returnBytes = new bytes(4 * numFacetSelectors);\\n        uint256 bytePosition;\\n        for (uint256 i; i < numFacetSelectors; i++) {\\n            for (uint256 j; j < 4; j++) {\\n                returnBytes[bytePosition] = bytes1(\\n                    facetSelectors[i] << (j * 8)\\n                );\\n                bytePosition++;\\n            }\\n        }\\n        return returnBytes;\\n    }\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return A byte array of tightly packed facet addresses.\\n    /// Example return value:\\n    /// return abi.encodePacked(facet1, facet2, facet3, ...)\\n    function facetAddresses() external override view returns (bytes memory) {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 totalSelectorSlots = ds.selectorSlotsLength;\\n        uint256 totalSelectors = uint128(totalSelectorSlots) *\\n            8 +\\n            uint128(totalSelectorSlots >> 128);\\n\\n        address[] memory facets_ = new address[](totalSelectors);\\n        uint256 numFacets;\\n        uint256 selectorCount;\\n        // loop through function selectors\\n        for (uint256 slotIndex; selectorCount < totalSelectors; slotIndex++) {\\n            bytes32 slot = ds.selectorSlots[slotIndex];\\n            for (uint256 selectorIndex; selectorIndex < 8; selectorIndex++) {\\n                selectorCount++;\\n                if (selectorCount > totalSelectors) {\\n                    break;\\n                }\\n                bytes4 selector = bytes4(slot << (selectorIndex * 32));\\n                address facet = address(bytes20(ds.facets[selector]));\\n                bool continueLoop = false;\\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n                    if (facet == facets_[facetIndex]) {\\n                        continueLoop = true;\\n                        break;\\n                    }\\n                }\\n                if (continueLoop) {\\n                    continueLoop = false;\\n                    continue;\\n                }\\n                facets_[numFacets] = facet;\\n                numFacets++;\\n            }\\n        }\\n\\n        bytes memory returnBytes = new bytes(20 * numFacets);\\n        uint256 bytePosition;\\n        for (uint256 i; i < numFacets; i++) {\\n            for (uint256 j; j < 20; j++) {\\n                returnBytes[bytePosition] = bytes1(\\n                    bytes20(facets_[i]) << (j * 8)\\n                );\\n                bytePosition++;\\n            }\\n        }\\n        return returnBytes;\\n    }\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return The facet address.\\n    function facetAddress(bytes4 _functionSelector)\\n        external\\n        override\\n        view\\n        returns (address)\\n    {\\n        DiamondStorage storage ds = diamondStorage();\\n        return address(bytes20(ds.facets[_functionSelector]));\\n    }\\n}\\n\",\"keccak256\":\"0xdf3a2433d5ed5924039184d3cf73a6c6f41da8eec00f5595d3656b6352e364a9\"},\"solc_0.6/proxy/diamond/DiamondStorageContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.4;\\n\\n// * from https://github.com/mudgen/Diamond/blob/ca15562a2858a4a4696526b1f6b18a4adef10617/contracts/\\n\\ncontract DiamondStorageContract {\\n    struct DiamondStorage {\\n        // owner of the contract\\n        address contractOwner;\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to the slot in the selectorSlots array.\\n        // and maps the selectors to the position in the slot.\\n        // func selector => address facet, uint32 slotIndex, uint64 slotsIndex\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // uint32 selectorSlotLength, uint32 selectorSlotsLength\\n        // selectorSlotsLength is the number of 32-byte slots in selectorSlots.\\n        // selectorSlotLength is the number of selectors in the last slot of\\n        // selectorSlots.\\n        uint256 selectorSlotsLength;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        // ds_slot = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n        assembly {\\n            ds_slot := 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x626daf4e7c071a662567c0bdf8a2488d3a194898c9e013e32b626b2519cea044\"},\"solc_0.6/proxy/diamond/ERC173.sol\":{\"content\":\"pragma solidity ^0.6.4;\\n\\nimport \\\"./ERC173Events.sol\\\";\\n\\ninterface ERC173 is ERC173Events {\\n    function transferOwnership(address newOwner) external;\\n\\n    function owner() external view returns (address);\\n}\\n\",\"keccak256\":\"0xead356d45d6f7ca020945d12fb7ae2282d3b1dc0820a197f5748c5f05fd5a6de\"},\"solc_0.6/proxy/diamond/ERC173Events.sol\":{\"content\":\"pragma solidity ^0.6.4;\\n\\ninterface ERC173Events {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n}\\n\",\"keccak256\":\"0x36b00d615382fbedee111f6a409f203f30faa02d233da4c315782878f14134ef\"},\"solc_0.6/proxy/diamond/OwnershipFacet.sol\":{\"content\":\"pragma solidity ^0.6.4;\\n\\nimport \\\"./DiamondStorageContract.sol\\\";\\nimport \\\"./ERC173.sol\\\";\\n\\ncontract OwnershipFacet is ERC173, DiamondStorageContract {\\n    function transferOwnership(address newOwner) external override {\\n        DiamondStorage storage ds = diamondStorage();\\n        address currentOwner = ds.contractOwner;\\n        require(msg.sender == currentOwner, \\\"Must own the contract.\\\");\\n        ds.contractOwner = newOwner;\\n        emit OwnershipTransferred(currentOwner, newOwner);\\n    }\\n\\n    function owner() external override view returns (address) {\\n        DiamondStorage storage ds = diamondStorage();\\n        return ds.contractOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x838f1a8178c11c709387d752b80b6f7ffd4a0ad5e858a53a6af0386093e2b5e5\"}},\"version\":1}",
  "contractFilepath": "solc_0.6/proxy/diamond/DiamondBase.sol"
}
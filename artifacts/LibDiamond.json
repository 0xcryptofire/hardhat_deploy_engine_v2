{
  "contractName": "LibDiamond",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes[]",
          "name": "_diamondCut",
          "type": "bytes[]"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_init",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "_calldata",
          "type": "bytes"
        }
      ],
      "name": "DiamondCut",
      "type": "event"
    }
  ],
  "bytecode": "0x60566023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122080118fbf8cfbab46bb87626a085325ce52306f0242e454edc1f76477b181bf1e64736f6c63430007010033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122080118fbf8cfbab46bb87626a085325ce52306f0242e454edc1f76477b181bf1e64736f6c63430007010033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "metadata": "{\"compiler\":{\"version\":\"0.7.1+commit.f4a555be\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"_diamondCut\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solc_0.7/diamond/libraries/LibDiamond.sol\":\"LibDiamond\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"solc_0.7/diamond/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge\\n*\\n* Implementation of Diamond facet.\\n* This is gas optimized by reducing storage reads and storage writes.\\n* This code is as complex as it is to reduce gas costs.\\n/******************************************************************************/\\n\\nimport {LibDiamondStorage} from \\\"./LibDiamondStorage.sol\\\";\\n\\nlibrary LibDiamond {\\n    event DiamondCut(bytes[] _diamondCut, address _init, bytes _calldata);\\n\\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(\\n        uint256(0xffffffffffffffffffffffff)\\n    );\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    // This struct is used to prevent getting the error \\\"CompilerError: Stack too deep, try removing local variables.\\\"\\n    // See this article: https://medium.com/1milliondevs/compilererror-stack-too-deep-try-removing-local-variables-solved-a6bcecc16231\\n    struct SlotInfo {\\n        uint256 originalSelectorCount;\\n        uint256 newSelectorCount;\\n        bytes32 selectorSlot;\\n        uint256 oldSelectorsSlotCount;\\n        uint256 oldSelectorsInSlot;\\n        bytes32 oldSelectorSlot;\\n        bool updateLastSlot;\\n    }\\n\\n    // Non-standard internal function version of diamondCut\\n    // This code is almost the same as externalCut, except it is using\\n    // 'bytes[] memory _diamondCut' instead of 'bytes[] calldata _diamondCut'\\n    // and it DOES issue the DiamondCut event\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes an error for an array of bytes arrays.\\n    function diamondCut(bytes[] memory _diamondCut) internal {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage\\n            .diamondStorage();\\n        SlotInfo memory slot;\\n        slot.originalSelectorCount = ds.selectorCount;\\n        uint256 selectorSlotCount = slot.originalSelectorCount / 8;\\n        uint256 selectorsInSlot = slot.originalSelectorCount % 8;\\n        if (selectorsInSlot > 0) {\\n            slot.selectorSlot = ds.selectorSlots[selectorSlotCount];\\n        }\\n        // loop through diamond cut\\n        for (\\n            uint256 diamondCutIndex;\\n            diamondCutIndex < _diamondCut.length;\\n            diamondCutIndex++\\n        ) {\\n            bytes memory facetCut = _diamondCut[diamondCutIndex];\\n            require(\\n                facetCut.length > 20,\\n                \\\"LibDiamond: Missing facet or selector info.\\\"\\n            );\\n            bytes32 currentSlot;\\n            assembly {\\n                currentSlot := mload(add(facetCut, 32))\\n            }\\n            bytes32 newFacet = bytes20(currentSlot);\\n            uint256 numSelectors = (facetCut.length - 20) / 4;\\n            uint256 position = 52;\\n\\n            // adding or replacing functions\\n            if (newFacet != 0) {\\n                // add and replace selectors\\n                for (\\n                    uint256 selectorIndex;\\n                    selectorIndex < numSelectors;\\n                    selectorIndex++\\n                ) {\\n                    bytes4 selector;\\n                    assembly {\\n                        selector := mload(add(facetCut, position))\\n                    }\\n                    position += 4;\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    // add\\n                    if (oldFacet == 0) {\\n                        // update the last slot at then end of the function\\n                        slot.updateLastSlot = true;\\n                        ds.facets[selector] =\\n                            newFacet |\\n                            (bytes32(selectorsInSlot) << 64) |\\n                            bytes32(selectorSlotCount);\\n                        // clear selector position in slot and add selector\\n                        slot.selectorSlot =\\n                            (slot.selectorSlot &\\n                                ~(CLEAR_SELECTOR_MASK >>\\n                                    (selectorsInSlot * 32))) |\\n                            (bytes32(selector) >> (selectorsInSlot * 32));\\n                        selectorsInSlot++;\\n                        // if slot is full then write it to storage\\n                        if (selectorsInSlot == 8) {\\n                            ds.selectorSlots[selectorSlotCount] = slot\\n                                .selectorSlot;\\n                            slot.selectorSlot = 0;\\n                            selectorsInSlot = 0;\\n                            selectorSlotCount++;\\n                        }\\n                    } else {\\n                        // replace\\n                        require(\\n                            bytes20(oldFacet) != bytes20(newFacet),\\n                            \\\"Function cut to same facet.\\\"\\n                        );\\n                        // replace old facet address\\n                        ds.facets[selector] =\\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\\n                            newFacet;\\n                    }\\n                }\\n            } else {\\n                // remove functions\\n                slot.updateLastSlot = true;\\n                for (\\n                    uint256 selectorIndex;\\n                    selectorIndex < numSelectors;\\n                    selectorIndex++\\n                ) {\\n                    bytes4 selector;\\n                    assembly {\\n                        selector := mload(add(facetCut, position))\\n                    }\\n                    position += 4;\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    require(\\n                        oldFacet != 0,\\n                        \\\"Function doesn't exist. Can't remove.\\\"\\n                    );\\n                    // Current slot is empty so get the slot before it\\n                    if (slot.selectorSlot == 0) {\\n                        selectorSlotCount--;\\n                        slot.selectorSlot = ds.selectorSlots[selectorSlotCount];\\n                        selectorsInSlot = 8;\\n                    }\\n                    slot.oldSelectorsSlotCount = uint64(uint256(oldFacet));\\n                    slot.oldSelectorsInSlot = uint32(uint256(oldFacet >> 64));\\n                    // gets the last selector in the slot\\n                    bytes4 lastSelector = bytes4(\\n                        slot.selectorSlot << ((selectorsInSlot - 1) * 32)\\n                    );\\n                    if (slot.oldSelectorsSlotCount != selectorSlotCount) {\\n                        slot.oldSelectorSlot = ds.selectorSlots[slot\\n                            .oldSelectorsSlotCount];\\n                        // clears the selector we are deleting and puts the last selector in its place.\\n                        slot.oldSelectorSlot =\\n                            (slot.oldSelectorSlot &\\n                                ~(CLEAR_SELECTOR_MASK >>\\n                                    (slot.oldSelectorsInSlot * 32))) |\\n                            (bytes32(lastSelector) >>\\n                                (slot.oldSelectorsInSlot * 32));\\n                        // update storage with the modified slot\\n                        ds.selectorSlots[slot.oldSelectorsSlotCount] = slot\\n                            .oldSelectorSlot;\\n                        selectorsInSlot--;\\n                    } else {\\n                        // clears the selector we are deleting and puts the last selector in its place.\\n                        slot.selectorSlot =\\n                            (slot.selectorSlot &\\n                                ~(CLEAR_SELECTOR_MASK >>\\n                                    (slot.oldSelectorsInSlot * 32))) |\\n                            (bytes32(lastSelector) >>\\n                                (slot.oldSelectorsInSlot * 32));\\n                        selectorsInSlot--;\\n                    }\\n                    if (selectorsInSlot == 0) {\\n                        delete ds.selectorSlots[selectorSlotCount];\\n                        slot.selectorSlot = 0;\\n                    }\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        ds.facets[lastSelector] =\\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\\n                            bytes20(ds.facets[lastSelector]);\\n                    }\\n                    delete ds.facets[selector];\\n                }\\n            }\\n        }\\n        slot.newSelectorCount = selectorSlotCount * 8 + selectorsInSlot;\\n        if (slot.newSelectorCount != slot.originalSelectorCount) {\\n            ds.selectorCount = slot.newSelectorCount;\\n        }\\n        if (slot.updateLastSlot && selectorsInSlot > 0) {\\n            ds.selectorSlots[selectorSlotCount] = slot.selectorSlot;\\n        }\\n        emit DiamondCut(_diamondCut, address(0), new bytes(0));\\n    }\\n}\\n\",\"keccak256\":\"0x64f4802932ada84eb152ce375e1c472cf8395b13d04d723a8e0a583e8ba7919b\",\"license\":\"MIT\"},\"solc_0.7/diamond/libraries/LibDiamondStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\n\\nlibrary LibDiamondStorage {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\n        \\\"diamond.standard.diamond.storage\\\"\\n    );\\n\\n    struct DiamondStorage {\\n        // owner of the contract\\n        address contractOwner;\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to the slot in the selectorSlots array.\\n        // and maps the selectors to the position in the slot.\\n        // func selector => address facet, uint32 slotIndex, uint64 slotsIndex\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // The number of function selectors in selectorSlots\\n        uint256 selectorCount;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x17e971b2e73a8a8d7f8251edb68f78c3a45c286351a71e7e6df82b427bb739d3\",\"license\":\"MIT\"}},\"version\":1}",
  "contractFilepath": "solc_0.7/diamond/libraries/LibDiamond.sol"
}